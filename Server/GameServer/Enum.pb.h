// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Enum.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Enum_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Enum_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Enum_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Enum_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Enum_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

enum RoomFailReason : int {
  NONE = 0,
  CREATE_ROOM = 1,
  EXIST_ROOM = 2,
  FULL_ROOM = 3,
  PLAYED_ROOM = 4,
  RoomFailReason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RoomFailReason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RoomFailReason_IsValid(int value);
constexpr RoomFailReason RoomFailReason_MIN = NONE;
constexpr RoomFailReason RoomFailReason_MAX = PLAYED_ROOM;
constexpr int RoomFailReason_ARRAYSIZE = RoomFailReason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RoomFailReason_descriptor();
template<typename T>
inline const std::string& RoomFailReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoomFailReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoomFailReason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RoomFailReason_descriptor(), enum_t_value);
}
inline bool RoomFailReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RoomFailReason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RoomFailReason>(
    RoomFailReason_descriptor(), name, value);
}
enum RoomState : int {
  ROOM_STATE_NONE = 0,
  ROOM_STATE_LOBBY = 1,
  ROOM_STATE_PLAYING = 3,
  RoomState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RoomState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RoomState_IsValid(int value);
constexpr RoomState RoomState_MIN = ROOM_STATE_NONE;
constexpr RoomState RoomState_MAX = ROOM_STATE_PLAYING;
constexpr int RoomState_ARRAYSIZE = RoomState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RoomState_descriptor();
template<typename T>
inline const std::string& RoomState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoomState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoomState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RoomState_descriptor(), enum_t_value);
}
inline bool RoomState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RoomState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RoomState>(
    RoomState_descriptor(), name, value);
}
enum RoundState : int {
  ROUND_STATE_NONE = 0,
  ROUND_STATE_LODDINGWAIT = 1,
  ROUND_STATE_PLAYING = 2,
  ROUND_STATE_RESULT = 4,
  ROUND_STATE_END_GAME = 5,
  ROUND_STATE_FINAL = 6,
  RoundState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RoundState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RoundState_IsValid(int value);
constexpr RoundState RoundState_MIN = ROUND_STATE_NONE;
constexpr RoundState RoundState_MAX = ROUND_STATE_FINAL;
constexpr int RoundState_ARRAYSIZE = RoundState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RoundState_descriptor();
template<typename T>
inline const std::string& RoundState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoundState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoundState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RoundState_descriptor(), enum_t_value);
}
inline bool RoundState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RoundState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RoundState>(
    RoundState_descriptor(), name, value);
}
enum Vgun : int {
  VGUN_NONE = 0,
  VGUN_CARROT_1 = 11,
  VGUN_CARROT_2 = 12,
  VGUN_CARROT_3 = 13,
  VGUN_WATERMELON_1 = 21,
  VGUN_WATERMELON_2 = 22,
  VGUN_WATERMELON_3 = 23,
  VGUN_KIWI_1 = 31,
  VGUN_KIWI_2 = 32,
  VGUN_KIWI_3 = 33,
  VGUN_BANANA_1 = 41,
  VGUN_BANANA_2 = 42,
  VGUN_BANANA_3 = 43,
  Vgun_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Vgun_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Vgun_IsValid(int value);
constexpr Vgun Vgun_MIN = VGUN_NONE;
constexpr Vgun Vgun_MAX = VGUN_BANANA_3;
constexpr int Vgun_ARRAYSIZE = Vgun_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Vgun_descriptor();
template<typename T>
inline const std::string& Vgun_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Vgun>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Vgun_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Vgun_descriptor(), enum_t_value);
}
inline bool Vgun_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Vgun* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Vgun>(
    Vgun_descriptor(), name, value);
}
enum Parts : int {
  PARTS_NONE = 0,
  PARTS_Vgun = 1,
  PARTS_DAMAGE = 2,
  PARTS_RELOADTIME = 3,
  PARTS_MOVESPEED = 4,
  PARTS_BULLETCAPACITY = 5,
  PARTS_HEALTHPOINT = 6,
  PARTS_ISABLEDOUBLEJUMP = 7,
  PARTS_VGUN_CARROT = 11,
  PARTS_VGUN_WATERMELON = 12,
  PARTS_VGUN_KIWI = 13,
  PARTS_VGUN_BANANA = 14,
  PARTS_FIRERATE = 112,
  PARTS_BULLETSHOTCOUNT = 117,
  PARTS_OVERALLDAMAGE = 119,
  Parts_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Parts_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Parts_IsValid(int value);
constexpr Parts Parts_MIN = PARTS_NONE;
constexpr Parts Parts_MAX = PARTS_OVERALLDAMAGE;
constexpr int Parts_ARRAYSIZE = Parts_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Parts_descriptor();
template<typename T>
inline const std::string& Parts_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Parts>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Parts_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Parts_descriptor(), enum_t_value);
}
inline bool Parts_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Parts* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Parts>(
    Parts_descriptor(), name, value);
}
enum AttackPoint : int {
  ATTACK_POINT_NONE = 0,
  ATTACK_POINT_HEAD = 1,
  ATTACK_POINT_BODY = 2,
  ATTACK_POINT_LEG = 3,
  AttackPoint_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AttackPoint_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AttackPoint_IsValid(int value);
constexpr AttackPoint AttackPoint_MIN = ATTACK_POINT_NONE;
constexpr AttackPoint AttackPoint_MAX = ATTACK_POINT_LEG;
constexpr int AttackPoint_ARRAYSIZE = AttackPoint_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AttackPoint_descriptor();
template<typename T>
inline const std::string& AttackPoint_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AttackPoint>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AttackPoint_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AttackPoint_descriptor(), enum_t_value);
}
inline bool AttackPoint_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AttackPoint* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AttackPoint>(
    AttackPoint_descriptor(), name, value);
}
enum AnimState : int {
  ANIM_NONE = 0,
  ANIM_IDLE = 1,
  ANIM_DIE = 2,
  ANIM_JUMP = 3,
  ANIM_MOVE_FORWARD = 4,
  ANIM_MOVE_LEFT = 5,
  ANIM_MOVE_RIGHT = 6,
  ANIM_RELOAD = 7,
  ANIM_SHOOT = 8,
  AnimState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AnimState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AnimState_IsValid(int value);
constexpr AnimState AnimState_MIN = ANIM_NONE;
constexpr AnimState AnimState_MAX = ANIM_SHOOT;
constexpr int AnimState_ARRAYSIZE = AnimState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AnimState_descriptor();
template<typename T>
inline const std::string& AnimState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AnimState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AnimState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AnimState_descriptor(), enum_t_value);
}
inline bool AnimState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AnimState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AnimState>(
    AnimState_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Protocol::RoomFailReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::RoomFailReason>() {
  return ::Protocol::RoomFailReason_descriptor();
}
template <> struct is_proto_enum< ::Protocol::RoomState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::RoomState>() {
  return ::Protocol::RoomState_descriptor();
}
template <> struct is_proto_enum< ::Protocol::RoundState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::RoundState>() {
  return ::Protocol::RoundState_descriptor();
}
template <> struct is_proto_enum< ::Protocol::Vgun> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::Vgun>() {
  return ::Protocol::Vgun_descriptor();
}
template <> struct is_proto_enum< ::Protocol::Parts> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::Parts>() {
  return ::Protocol::Parts_descriptor();
}
template <> struct is_proto_enum< ::Protocol::AttackPoint> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::AttackPoint>() {
  return ::Protocol::AttackPoint_descriptor();
}
template <> struct is_proto_enum< ::Protocol::AnimState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::AnimState>() {
  return ::Protocol::AnimState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Enum_2eproto
