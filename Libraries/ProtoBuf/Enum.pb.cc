// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Enum.proto

#include "Enum.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace Protocol {
}  // namespace Protocol
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_Enum_2eproto[7];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_Enum_2eproto = nullptr;
const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_Enum_2eproto::offsets[1] = {};
static constexpr ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema* schemas = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::Message* const* file_default_instances = nullptr;

const char descriptor_table_protodef_Enum_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\nEnum.proto\022\010Protocol*[\n\016RoomFailReason"
  "\022\010\n\004NONE\020\000\022\017\n\013CREATE_ROOM\020\001\022\016\n\nEXIST_ROO"
  "M\020\002\022\r\n\tFULL_ROOM\020\003\022\017\n\013PLAYED_ROOM\020\004*N\n\tR"
  "oomState\022\023\n\017ROOM_STATE_NONE\020\000\022\024\n\020ROOM_ST"
  "ATE_LOBBY\020\001\022\026\n\022ROOM_STATE_PLAYING\020\003*\241\001\n\n"
  "RoundState\022\024\n\020ROUND_STATE_NONE\020\000\022\033\n\027ROUN"
  "D_STATE_LODDINGWAIT\020\001\022\027\n\023ROUND_STATE_PLA"
  "YING\020\002\022\026\n\022ROUND_STATE_RESULT\020\004\022\030\n\024ROUND_"
  "STATE_END_GAME\020\005\022\025\n\021ROUND_STATE_FINAL\020\006*"
  "\377\001\n\004Vgun\022\r\n\tVGUN_NONE\020\000\022\021\n\rVGUN_CARROT_1"
  "\020\013\022\021\n\rVGUN_CARROT_2\020\014\022\021\n\rVGUN_CARROT_3\020\r"
  "\022\025\n\021VGUN_WATERMELON_1\020\025\022\025\n\021VGUN_WATERMEL"
  "ON_2\020\026\022\025\n\021VGUN_WATERMELON_3\020\027\022\017\n\013VGUN_KI"
  "WI_1\020\037\022\017\n\013VGUN_KIWI_2\020 \022\017\n\013VGUN_KIWI_3\020!"
  "\022\021\n\rVGUN_BANANA_1\020)\022\021\n\rVGUN_BANANA_2\020*\022\021"
  "\n\rVGUN_BANANA_3\020+*\327\002\n\005Parts\022\016\n\nPARTS_NON"
  "E\020\000\022\016\n\nPARTS_Vgun\020\001\022\020\n\014PARTS_DAMAGE\020\002\022\024\n"
  "\020PARTS_RELOADTIME\020\003\022\023\n\017PARTS_MOVESPEED\020\004"
  "\022\030\n\024PARTS_BULLETCAPACITY\020\005\022\025\n\021PARTS_HEAL"
  "THPOINT\020\006\022\032\n\026PARTS_ISABLEDOUBLEJUMP\020\007\022\025\n"
  "\021PARTS_VGUN_CARROT\020\013\022\031\n\025PARTS_VGUN_WATER"
  "MELON\020\014\022\023\n\017PARTS_VGUN_KIWI\020\r\022\025\n\021PARTS_VG"
  "UN_BANANA\020\016\022\022\n\016PARTS_FIRERATE\020p\022\031\n\025PARTS"
  "_BULLETSHOTCOUNT\020u\022\027\n\023PARTS_OVERALLDAMAG"
  "E\020w*h\n\013AttackPoint\022\025\n\021ATTACK_POINT_NONE\020"
  "\000\022\025\n\021ATTACK_POINT_HEAD\020\001\022\025\n\021ATTACK_POINT"
  "_BODY\020\002\022\024\n\020ATTACK_POINT_LEG\020\003*\247\001\n\tAnimSt"
  "ate\022\r\n\tANIM_NONE\020\000\022\r\n\tANIM_IDLE\020\001\022\014\n\010ANI"
  "M_DIE\020\002\022\r\n\tANIM_JUMP\020\003\022\025\n\021ANIM_MOVE_FORW"
  "ARD\020\004\022\022\n\016ANIM_MOVE_LEFT\020\005\022\023\n\017ANIM_MOVE_R"
  "IGHT\020\006\022\017\n\013ANIM_RELOAD\020\007\022\016\n\nANIM_SHOOT\020\010b"
  "\006proto3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_Enum_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Enum_2eproto = {
  false, false, 1247, descriptor_table_protodef_Enum_2eproto, "Enum.proto", 
  &descriptor_table_Enum_2eproto_once, nullptr, 0, 0,
  schemas, file_default_instances, TableStruct_Enum_2eproto::offsets,
  nullptr, file_level_enum_descriptors_Enum_2eproto, file_level_service_descriptors_Enum_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_Enum_2eproto_getter() {
  return &descriptor_table_Enum_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_Enum_2eproto(&descriptor_table_Enum_2eproto);
namespace Protocol {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RoomFailReason_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Enum_2eproto);
  return file_level_enum_descriptors_Enum_2eproto[0];
}
bool RoomFailReason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RoomState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Enum_2eproto);
  return file_level_enum_descriptors_Enum_2eproto[1];
}
bool RoomState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RoundState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Enum_2eproto);
  return file_level_enum_descriptors_Enum_2eproto[2];
}
bool RoundState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Vgun_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Enum_2eproto);
  return file_level_enum_descriptors_Enum_2eproto[3];
}
bool Vgun_IsValid(int value) {
  switch (value) {
    case 0:
    case 11:
    case 12:
    case 13:
    case 21:
    case 22:
    case 23:
    case 31:
    case 32:
    case 33:
    case 41:
    case 42:
    case 43:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Parts_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Enum_2eproto);
  return file_level_enum_descriptors_Enum_2eproto[4];
}
bool Parts_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 11:
    case 12:
    case 13:
    case 14:
    case 112:
    case 117:
    case 119:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AttackPoint_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Enum_2eproto);
  return file_level_enum_descriptors_Enum_2eproto[5];
}
bool AttackPoint_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AnimState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Enum_2eproto);
  return file_level_enum_descriptors_Enum_2eproto[6];
}
bool AnimState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
